# Production Postgres & Migration Strategy

This document describes how to safely manage schema changes and deploy application updates with minimal risk.

## Goals
- Zero/low-downtime migrations when feasible
- Clear gating in CI/CD to catch drift early
- Rollback strategy for both app and database
- Secrets management and environment separation

## Environments
- Development: local SQLite or Postgres
- CI: Ephemeral Postgres service (see `.github/workflows/ci.yml`)
- Production: Managed Postgres (Neon/Supabase/etc.)

## Core Principles
1) Forward-only migrations: never edit old migration files; create new ones.
2) Small steps: prefer multiple smaller migrations over a large one.
3) Backward compatible releases:
   - Phase A: Add new columns/tables; keep old fields operational.
   - Phase B: Deploy app reading/writing both (migrate data if needed).
   - Phase C: Remove old fields with a follow-up migration once traffic has moved.
4) Gate deploys on `prisma migrate status` + `prisma migrate deploy`.

## CI/CD Gating
- CI (`ci.yml`) runs:
  - `npx prisma migrate status` to surface drift
  - `npx prisma migrate deploy` to validate migrations apply cleanly
- Prod deploy (when enabled) should run the same sequence before switching traffic.

## Operational Runbook
- Pre-Deploy:
  - Ensure migrations are generated (`prisma migrate dev` locally) and committed.
  - Confirm app code works with both old and new schema if not an instant cutover.
- Deploy:
  - Run `prisma migrate deploy` against production DATABASE_URL.
  - Build and deploy the app (Vercel prod or container).
- Post-Deploy:
  - Monitor error rates, response times, DB locks.
  - If issues: rollback app (redeploy previous build). If schema breaking, apply a revert migration.

## Rollback Strategies
- App rollback: redeploy previous version (keep backwards-compat during transition).
- DB rollback: use a dedicated revert migration (generated by hand) or restore a PITR fork and route traffic temporarily, then forward-fix.

## Connection Management
- Use provider connection pooling (Neon/Supabase) or pgbouncer.
- For Prisma, adjust pool via connection string when needed, e.g. `?connection_limit=5` (provider-dependent) or Prisma pool settings when supported.
- Keep short transactions; index long-running queries.

## Read Replicas (Optional)
- Offload heavy read-only analytics to replicas; ensure consistency for user-facing analytics as needed.

## Secrets Management
- GitHub Actions: use repository or environment secrets (production environment recommended).
- Vercel: set environment variables per environment (development/preview/production).

## Maintenance Windows (if needed)
- For destructive changes that canâ€™t be made online, schedule a short window; present read-only mode if applicable.

## Verification & Monitoring
- After migration, run a quick smoke test: counts, recent rows queries (see `npm run backup:verify`).
- Monitor DB locks, slow queries, and error rates. Add alerts as the system matures.

## References
- Prisma Migrate: https://www.prisma.io/docs/orm/prisma-migrate
- Vercel Environments: https://vercel.com/docs/deployments/environments
